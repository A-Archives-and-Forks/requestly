import { create } from "zustand";
import { RQAPI } from "../types";
import { extractAuthHeadersAndParams } from "../helpers/auth";
export type KeyValuePair = { key: string; value: string };
type Namespace = "auth";

interface NamespaceContents {
  queryParams: KeyValuePair[];
  headers: Map<string, string>;
}

export interface AutogeneratedFieldsStore {
  namespaces: Record<Namespace, NamespaceContents>;
  headerVersion: number;
  queryParamsVersion: number;

  //Header methods
  _addHeaders: (namespace: Namespace, params: Record<string, string>) => void;
  _removeHeaders: (namespace: Namespace, key: string) => void;
  clearNamespace: (namespace: Namespace, skipVersionUpdate?: boolean) => void;
  purgeAndAddHeaders: (namespace: Namespace, params: Record<string, string>) => void;
  getAllHeaders: () => KeyValuePair[];
  getAllQueryParams: () => KeyValuePair[];
  _addQueryparams: (namespace: Namespace, params: KeyValuePair[]) => void;
  purgeAndAddQueryParams: (namespace: Namespace, params: KeyValuePair[]) => void;
}

const parseAuth = (auth: RQAPI.Auth): NamespaceContents => {
  // extract the auth from config & push them in header map
  // handle how i will store the key value pair here
  // ---> now here we can use that function already defined since it has the same signature of params
  const { headers, queryParams } = extractAuthHeadersAndParams(auth);
  //convert the headers from KP to map
  const headersMap = new Map<string, string>();
  headers.forEach(({ key, value }) => {
    headersMap.set(key, value);
  });

  const queryParamsContent: KeyValuePair[] = [];
  queryParams.forEach(({ key, value }) => {
    queryParamsContent.push({ key, value });
  });

  return {
    queryParams: queryParamsContent,
    headers: headersMap,
  };
};
// const parseContentType = (contentType: RequestContentType) => {
//     const queryParams: KeyValuePair[] = [];
//     const headersMap = new Map<string, string>();
//     headersMap.set("content-type", contentType);
//     return {
//         queryParams,
//         headers: headersMap
//     }
// }
const parseRequestEntry = (entry: RQAPI.Entry) => {
  // we have to return the final namespaces structure that is intialized here
  // from the entry itself we will fetch the auth & corresponding value for headers will be taken out & added to the headers
  const { auth } = entry || {};
  const authNamespaceContents = parseAuth(auth);
  //const contentTypeContents = parseContentType(request.contentType);

  return {
    auth: authNamespaceContents,
  };
};

export const createAutogeneratedStore = (entry: RQAPI.Entry) => {
  return create<AutogeneratedFieldsStore>()((set, get) => ({
    namespaces: parseRequestEntry(entry),
    headerVersion: 0,
    queryParamsVersion: 0,

    _addHeaders: (namespace: Namespace, params: Record<string, string>) => {
      const { headerVersion, namespaces } = get();
      const updatedHeaders = new Map<string, string>();

      Object.entries(params).forEach(([key, value]) => {
        updatedHeaders.set(key, value);
      });

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            headers: updatedHeaders,
          },
        },
        headerVersion: headerVersion + 1,
      };
      console.log("DBG-x", updatedState);
      set(updatedState);
    },

    _removeHeaders: (namespace: Namespace, key: string) => {
      //set(namespace, key);
      // this is not needed now
    },
    clearNamespace: (namespace: Namespace, skipVersionUpdate = false) => {
      // logic to clear all the namespace
      let { headerVersion, queryParamsVersion, namespaces } = get();
      delete namespaces[namespace];
      if (!skipVersionUpdate) {
        headerVersion++;
        queryParamsVersion++;
      }
      set({
        namespaces,
        headerVersion,
        queryParamsVersion,
      });
    },
    purgeAndAddHeaders: (namespace: Namespace, params: Record<string, string>) => {
      console.log("params", params);
      const { clearNamespace, _addHeaders } = get();
      clearNamespace(namespace, true);
      _addHeaders(namespace, params);
    },

    _addQueryparams: (namespace: Namespace, params: KeyValuePair[]) => {
      const { queryParamsVersion, namespaces } = get();

      console.log("DEBUG-HERE-1", params);

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            queryParams: params,
          },
        },
        queryParamsVersion: queryParamsVersion + 1,
      };
      set(updatedState);

      console.log("DEBUG-HERE-x", updatedState);
    },

    purgeAndAddQueryParams: (namespace: Namespace, params: KeyValuePair[]) => {
      const { clearNamespace, _addQueryparams } = get();
      clearNamespace(namespace, true);
      _addQueryparams(namespace, params);
    },

    getAllHeaders() {
      const result: KeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const { headers } = namespaces[namespace as Namespace];
        for (const headerEntry of headers.entries()) {
          const [key, value] = headerEntry;
          result.push({
            key,
            value,
          });
        }
      }
      return result;
    },

    getAllQueryParams() {
      const result: KeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const { queryParams } = namespaces[namespace as Namespace];
        for (const queryParam of queryParams) {
          result.push({
            key: queryParam.key,
            value: queryParam.value,
          });
        }
      }
      return result;
    },
  }));
};
